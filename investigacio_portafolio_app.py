# -*- coding: utf-8 -*-
"""INVESTIGACIO_PORTAFOLIO_APP

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fyetnasCW0VX90Al_FZYQMgTz2n6HIc1
"""

# Celda 1: instalar librerías necesarias
!pip install yfinance matplotlib seaborn pandas numpy scipy --quiet
# Celda 2: funciones core
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime

sns.set_style("whitegrid")
plt.rcParams["figure.figsize"] = (10,5)

def download_prices(tickers, start, end, interval='1d'):
    # Check if tickers is a list, if not, make it a list for consistent handling
    if isinstance(tickers, str):
        tickers = [tickers]

    # Download data. auto_adjust=False to keep 'Adj Close' column
    df = yf.download(tickers, start=start, end=end, interval=interval, progress=False, auto_adjust=False)

    # If downloading data for multiple tickers, it will be a MultiIndex DataFrame
    # If downloading data for a single ticker, it will be a DataFrame with a simple index
    # We want to return a DataFrame with the Adj Close prices for each ticker
    if isinstance(df.columns, pd.MultiIndex):
        # For multiple tickers, select the 'Adj Close' column from the MultiIndex
        df = df['Adj Close']
    else:
        # For a single ticker, the 'Adj Close' column is directly available
        df = df['Adj Close']

    # Ensure df is a DataFrame even for a single ticker
    if isinstance(df, pd.Series):
        df = df.to_frame(name=tickers[0]) # Name the column with the ticker symbol

    return df


def compute_returns(prices):
    rets = prices.pct_change().dropna()
    cum = (1 + rets).cumprod()
    return rets, cum

def compute_net_debt(info):
    total_debt = info.get('totalDebt', None)
    cash = info.get('totalCash', None) or info.get('cash', None)
    if total_debt is None:
        return None
    cash = cash or 0
    return float(total_debt) - float(cash)

def robust_extract_fcf(ticker_obj):
    try:
        cf = ticker_obj.cashflow
    except Exception:
        return None
    idx = [str(x) for x in cf.index]
    ops_idx = None
    capex_idx = None
    for i, name in enumerate(idx):
        n = name.lower()
        if ('operat' in n and ('cash' in n or 'activities' in n)) or 'total cash from operating' in n:
            ops_idx = cf.index[i]
        if 'capital expend' in n or 'capex' in n:
            capex_idx = cf.index[i]
    try:
        if ops_idx and capex_idx:
            ops = cf.loc[ops_idx].iloc[0]
            capex = cf.loc[capex_idx].iloc[0]
            fcf = float(ops) + float(capex)
            return fcf
    except Exception:
        pass
    info = ticker_obj.info
    fcf_info = info.get('freeCashflow', None)
    if fcf_info:
        try:
            return float(fcf_info)
        except:
            pass
    return None

def dcf_for_ticker(ticker, years=5, g=0.05, g_terminal=0.02, discount_rate=None, rf=0.03, market_premium=0.05):
    tk = yf.Ticker(ticker)
    info = tk.info
    fcf = robust_extract_fcf(tk)
    if fcf is None:
        return {"ticker": ticker, "error": "No FCF available"}
    beta = info.get('beta', None) or 1.0
    if discount_rate is None:
        r = rf + beta * market_premium
    else:
        r = discount_rate
    if r <= g_terminal:
        return {"ticker": ticker, "error": "Discount rate <= terminal growth"}
    fcf_proj = []
    last = float(fcf)
    for t in range(1, years + 1):
        last = last * (1 + g)
        fcf_proj.append(last)
    tv = fcf_proj[-1] * (1 + g_terminal) / (r - g_terminal)
    pv = sum([fcf_proj[i] / ((1 + r) ** (i + 1)) for i in range(years)]) + tv / ((1 + r) ** years)
    net_debt = compute_net_debt(info)
    equity_value = pv if net_debt is None else pv - net_debt
    shares = info.get('sharesOutstanding', None)
    if not shares or shares == 0:
        return {"ticker": ticker, "error": "Shares outstanding missing"}
    intrinsic_per_share = equity_value / shares
    market_price = info.get('regularMarketPrice', None)
    margin = None
    if market_price and intrinsic_per_share:
        margin = (intrinsic_per_share - market_price) / intrinsic_per_share
    return {
        "ticker": ticker,
        "fcf": fcf,
        "fcf_proj": fcf_proj,
        "tv": tv,
        "pv": pv,
        "net_debt": net_debt,
        "equity_value": equity_value,
        "shares": shares,
        "intrinsic_per_share": intrinsic_per_share,
        "market_price": market_price,
        "margin": margin,
        "discount_rate": r
    }

# Instalar una biblioteca (ejemplo: requests)
!pip install requests

# Celda 3: prueba básica
tickers = ["AAPL","MSFT","GOOGL"]
start = "2020-01-01"
end = datetime.today().strftime("%Y-%m-%d")
prices = download_prices(tickers, start, end, interval='1d')
print("Precios descargados — shape:", prices.shape)
prices.tail()

# Calcular retornos y mostrar gráfico
rets, cum = compute_returns(prices)
rets.mean().mul(252).plot(kind='bar', title='Retorno anual estimado por ticker')
plt.show()

# Celda 4: DCF por ticker
results = []
for t in tickers:
    res = dcf_for_ticker(t, years=5, g=0.05, g_terminal=0.02)
    results.append(res)
results



